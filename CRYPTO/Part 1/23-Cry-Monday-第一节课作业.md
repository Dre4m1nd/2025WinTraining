## 密码学？类魂？
**题目**

:::tips
这里是题目捏：

How at to by becamt drip fit cat Caurch get to hit all come at i becamt am pencal oi by forest van at dall becomt love fit hit ats



太岁的谏言:       即使摩斯密码早已跌落神坛了，也请成为古典密码之王吧

acemnorsuvwxz

bdfghijklpqtyABCDEFGHIJKLMNOPQRSTUVWXYZ

:::

**考点**：摩斯

无力吐槽，谁能想到题目在txt文档最后，怕我看见是吧（），亏我还对着那个图片翻了又翻，还以为是隐写（你欠我这里的怎么还，流泪破忒头）

回到题目，说了是摩斯，根据谏言，把acemnorsuvwxz换成点(.)，把bdfghijklpqtyABCDEFGHIJKLMNOPQRSTUVWXYZ换成杠(-)，得到的结果在线网站解密一下就行

![](https://cdn.nlark.com/yuque/0/2025/png/42554774/1737188557803-ae333a9e-9564-468d-810f-dad1b4f332a8.png)

flag：<font style="color:rgb(51, 51, 51);">NSSCTF{DANM-YOU-KNOWHAT-I-AM-SAY-BOOR}</font>



## 贝斯家族
**题目**

:::tips
<font style="color:rgb(80, 80, 80);">@iH<,{bdR2H;i6*Tm,Wx2izpx2!</font>

:::

**考点**：base系列编码

题目告诉我们是base系列编码了，所以上面这一段字符解一下base编码就行。本来想用CyberChef一把梭哈的，发现不行，说明不是简单的base编码，排除32，45，58，62，64，85，92这些CyberChef上已经有的编码，再去下面这个在线工具网站上翻翻

[http://www.hiencode.com/](http://www.hiencode.com/)

然后就发现是base91编码，解密一下就有flag了

![](https://cdn.nlark.com/yuque/0/2025/png/42554774/1737009058363-fb6099b0-6000-49e2-acdb-a6320286ae70.png)



flag：flag{554a5058c9021c76}



然后这里总结一下base系列的特点，参考了[https://www.cnblogs.com/0yst3r-2046/p/11962942.html](https://www.cnblogs.com/0yst3r-2046/p/11962942.html)这篇博客，大家也可以看看。

**base16**：编码后的字符只会在（0-9，A-F）（共16个）中出现，且**不用等号**

**base32**：编码后的字符只会在大写字母（A-Z）和数字234567 这32个字符组成，编码长度s40bit的倍数。<font style="color:rgb(77, 77, 77);">如果最后一组数据不足 5 个字节，会进行特殊处理来填充数据，确保数据长度为 5 的倍数。通常使用 "=" 字符进行填充。</font>**<font style="color:rgb(77, 77, 77);">意思就是base32结尾可能会有很多个等号</font>**

**base64**：编码后的字符只会在A-Z a-z 0-9（共62个）另外加上+/两个符号。如果要编码的字节数不能被3整除，最后会多出1个或2个字节，则用占位符= （一个代表一个字节）所以最多出现两个等号。**意思就是base64结尾可能会有且最多有两个等号**

**base58**：相比Base64，Base58不使用数字"0"，字母大写"O"，字母大写"I"，和字母小写"l"，以及"+"和"/"符号。没有标点符号，通常不会被从中间分行。

**base91**：顾名思义，base91需要**91个字符**来表示ASCII编码的二进制数据。 从94个可打印ASCII字符（0x21-0x7E）中，以下三个字符被省略：

-（破折号，0x2D）

\（反斜杠，0x5C）

'（撇号，0x27）

**base62**：Base62编码将数字转换为ASCII字符串（**0-9，a-z和A-Z**），反之亦然，这通常会导致字符串较短。26个小写字母+26个大写字母+10个数字=62

以上这些算是比较有特点的base系列编码了，具体要视情况分析到底是哪一种。



## .!?
**题目**

:::tips
..... ..... ..... ..... !?!!. ?.... ..... ..... ..... .?.?! .?... .!...

..... ..... !.?.. ..... !?!!. ?!!!! !!?.? !.?!! !!!.. ..... ..... .!.?.

..... ...!? !!.?. ..... ..?.? !.?.. ..... .!.?. ..... ..... !?!!. ?!!!!

!!!!! !?.?! .?!.? ..... ....! ?!!.? ..... ...?. ?!.?. ..... !.?.. .....

!?!!. ?!!!! !!?.? !.?!! !!!!! !!!!. ..... ...!. ?.... ...!? !!.?. .....

?.?!. ?..!. ?.... ..... !?!!. ?!!!! !!!!? .?!.? !!!!! !!!!! !!!.? .....

..!?! !.?.. ....? .?!.? ....! .!!!. !!!!! !!!!! !!!!! !!.?. ..... .!?!!

.?... ...?. ?!.?. ..... !.!!! !!!!! !.?.. ..... ..!?! !.?.. ..... .?.?!

.?... ..... !.?.

:::

**考点**：特殊编码

这第一眼看到肯定蒙，之前没有做过这道题，那没办法了，翻一下评论知道是Ook！编码，知道是什么加密后就简单了，在[https://www.splitbrain.org/services/ook](https://www.splitbrain.org/services/ook)这个网站解密一下就行了。

![](https://cdn.nlark.com/yuque/0/2025/png/42554774/1737012714307-ede6229e-afb8-4a73-81c5-547e8396dc8b.png)

没有办法，像这种特殊的编码方式只能特殊记。像什么核心价值观、与佛伦禅都是一眼就可以认出来的，就比较好记，所以只能遇见一个记一个，下面浅浅记录一下我见过的一些特殊编码。

**约佛伦禅**：以新佛曰等开头，后面跟着一段箴言，**形如**：新佛曰：諸隸僧降吽壽諸陀摩壽隸僧缽薩嚤訶壽陀壽夷所壽宣壽缽隸吽心壽吶菩囉菩修摩缽嚤宣諦陀壽兜咤壽須斯哆蜜吶嘇缽夷叻菩愍叻眾訶喼壽嘇諦如壽念囑囑（这个新版和旧版好像还不一样，旧版叫与佛论禅，以佛曰开头，遇到要用不同的在线网站解码）

**核心价值观编码**：形式就是一段核心价值观的文字，**形如**：公正爱国公正平等公正友善公正公正友善公正公正诚信平等文明富强法治法治公正友善敬业法治文明公正友善公正公正自由

**Brainfuck编码**：形如下面形式

:::tips
+++++ +++++ [->++ +++++ +++<] >++.+ +++++ .<+++ [->-- -<]>- -.+++ +++.<

++++[ ->+++ +<]>+ +++.< +++[- >---< ]>--- .---- .<+++ ++++[ ->--- ----<

]>--- ----- ----- .<+++ ++++[ ->+++ ++++< ]>+++ ++.<+ +++++ +[->- -----

-<]>. <++++ ++++[ ->+++ +++++ <]>++ .<+++ [->-- -<]>- ----. <++++ +++[-

>---- ---<] >---- ----. +++++ +..++ +++.+ .<+++ [->-- -<]>- --.<+ +++++

+[->+ +++++ +<]>+ ++.++ +.+++ +++++ +.--- -.+++ ++.<+ ++[-> +++<] >++++

++.<

:::

是很有特色的，看过一遍形式就可以记住

**Ook!编码**：形如下面形式

:::tips
Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.

Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook.

Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.

Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.

Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook. Ook. Ook. Ook. Ook.

Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook! Ook. Ook. Ook.

Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. 

:::

当然了它还有一个简单版本，就是去掉Ook，保留符号，就有了下面这个形式

:::tips
..... ..... ..... ..... !?!!. ?.... ..... ..... ..... .?.?! .?... .....

!.!!! !!!!. ..... ..... ....! .!... ....! .?.

:::

也就是我们这个题目的形式，特点是只有三种符号，特点很明显，见过一次就不会忘了

还有一些是题目本身会提醒你是什么编码，遇到之后如果怎么解都解不开可以搜一下题目，看看是不是一种特殊编码方式（记得buuctf上面就有一道的）

更多的特殊编码可以查看[链接](https://blog.csdn.net/fox_wayen/article/details/78235192?ops_request_misc=&request_id=&biz_id=102&utm_term=ook%EF%BC%81%E7%BC%96%E7%A0%81&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-5-78235192.142^v101^pc_search_result_base7&spm=1018.2226.3001.4187)，这篇博客里写的挺详细的



## rsa
**题目**

```python
#题目：
from Crypto.Util.number import *
import gmpy2
import libnum
from secret import flag,gen_x

m = bytes_to_long(flag)
p = libnum.generate_prime(512)
q = libnum.generate_prime(512)
n = p ** 3 * q
e = 65537

x = gen_x(p)

assert pow(22222222, x, p) == 1 ** 2024 and x%2024==0

m = m ^ x
c = pow(m, e, n)

print("q=", q)
print("n=", n)
print("e=", e)
print("c=", c)
"""
q = 13345672330679418443866848695749753384841350112452462690350565885192764753702964893062035116023096943358384379827500462723016224486435032522188166109529147
n = 4663711063632671446966617442890809468548735750386480905820144168615122369358088158709822723959108989276525102755551604204514586528122441075489492157644479194671784485228731421500391142158401889177506319977349707503678947872777602384171260874359045585814189677748712566088220734735479518470883541166059233676170283938881683675790979128058243582825012415020019043126740915522571217495119060031729061070896580899732991209113679151755713858497630999746612658308778711613697038750661479517187094033129979714688161348844542070263109259258937863241431480105798790363889436471998002323269704182369356300287043940743500087239
e = 65537
c = 130786470376510574523375214750425379158295834274599623287489104754006722808813934649176036178388384067040193592649530105616936502820754287181603236628515196039127654904821658246733136456930406056872602293196688418567911273536308460830968089020333890938433498027999776649550430971075113105774746267287227423835489272079766252409466100280571708298183082455075262759188421696753973647291264202685210088722673476268052692898681411789528976771007801550057078948950801205448228285783891241028681699434578897042694309109412171880394647978999519549451748870278523924392331514507178961276905501982709308644563098637335538179
"""
```

**考点**：欧拉函数，指数原根，异或

考察的地方很多，虽然最后写出来了，但总感觉有一个地方怪怪的，这个之后看。首先来分析题目。

题目给了我们q和n，那么我们可以根据![image](https://cdn.nlark.com/yuque/__latex/d5903e4bf89bb343c76c360d6d8d3f20.svg)可以求出p来，根据gmpy2库的iroot函数求p

`p = gmpy2.iroot(n//q,3)[0]`

有了p和q，那么我们就可以求解![image](https://cdn.nlark.com/yuque/__latex/cb18f6ee4265ccfd70524f5538a025a1.svg)

![image](https://cdn.nlark.com/yuque/__latex/6ea37e27a8f034798434aa365befdd3a.svg)

有了![image](https://cdn.nlark.com/yuque/__latex/cb18f6ee4265ccfd70524f5538a025a1.svg)我们求一下e关于这个的逆元就可以求出来d，有了d就标准rsa过程求解密文c，但是求出来的不是直接的m，我们先叫它m0。

我们知道m0是通过m和x异或后得到的，那么我们只要把m0和x再异或一下就可以求出m，所以现在差一个x，我们聚焦下面这个断言

`assert pow(22222222, x, p) == 1 ** 2024 and x%2024==0`

我们展开写一下这个式子可以得到

![image](https://cdn.nlark.com/yuque/__latex/e1172761ea4f2736f2b52b7e44137cc7.svg)

![image](https://cdn.nlark.com/yuque/__latex/c218d28341294919171039efa4457dcf.svg)

对于第一个式子，我们可以知道x是p的指数，这里就是我觉得奇怪的地方，如果不强调22222222是p的原根，这个x是不好解出来的，但是没有办法，我只能假设是原根，那么x就是![image](https://cdn.nlark.com/yuque/__latex/5940f4183da9f7dcc372430b4f8e1489.svg)的倍数（一个数论定理），同时x是2024的倍数，然后再去遍历一下可能值，就可以求出来明文了，代码如下

```python
from Crypto.Util.number import *
from Tools.scripts.pdeps import inverse
from gmpy2 import *
import libnum
q = 13345672330679418443866848695749753384841350112452462690350565885192764753702964893062035116023096943358384379827500462723016224486435032522188166109529147
n = 4663711063632671446966617442890809468548735750386480905820144168615122369358088158709822723959108989276525102755551604204514586528122441075489492157644479194671784485228731421500391142158401889177506319977349707503678947872777602384171260874359045585814189677748712566088220734735479518470883541166059233676170283938881683675790979128058243582825012415020019043126740915522571217495119060031729061070896580899732991209113679151755713858497630999746612658308778711613697038750661479517187094033129979714688161348844542070263109259258937863241431480105798790363889436471998002323269704182369356300287043940743500087239
e = 65537
c = 130786470376510574523375214750425379158295834274599623287489104754006722808813934649176036178388384067040193592649530105616936502820754287181603236628515196039127654904821658246733136456930406056872602293196688418567911273536308460830968089020333890938433498027999776649550430971075113105774746267287227423835489272079766252409466100280571708298183082455075262759188421696753973647291264202685210088722673476268052692898681411789528976771007801550057078948950801205448228285783891241028681699434578897042694309109412171880394647978999519549451748870278523924392331514507178961276905501982709308644563098637335538179

p = gmpy2.iroot(n//q,3)[0]
phi=(q-1)*(p**3-p**2)

d = gmpy2.invert(e,phi)
m = pow(c,d,n)
print(m)

for k in range(10000):
    if k*(p-1)%2024==0:
        # print(k)
        x = k*(p-1)
        m = pow(c, d, n)		# 这里直接把m的值放进来，或者像我这样写，不然每循环一次就异或一次，对结果有影响
        m= m ^ k*(p-1)
        if b'HnuSec' in long_to_bytes(m):	# 至于这个判断是我后面加的，让它好看一点，不知道也没关系，反正就是在最后结果里找一下就行
            print(long_to_bytes(m))
# HnuSec{welcome to rsa world}
```

其中注意一下第21行就行（反正我就卡这里好久，流泪猫猫头），然后这题就结束了，虽然那个是不是原根的问题还是没有解决，但反正解出来了（雾）

